# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig
from quixstreams.kafka import ConnectionConfig 
from pipeline import * 
from dash import Dash
from dash.dependencies import Input, Output
# import dash_core_components as dcc
# import dash_html_components as html
from dash import dcc, html
import plotly.graph_objs as go
import threading
from plotly.subplots import make_subplots





from river import metrics



from river import time_series











#Define metrics
mae = metrics.MAE()


#Define live data algorithms
HoltWinters = time_series.HoltWinters(
    alpha =0.3,
    beta =0.1,
    gamma =0.6,
    seasonality =12,
    multiplicative =True)


#Connection Configuration for quixstreams
connectionConfig = ConnectionConfig( 
    
    bootstrap_servers ="localhost:39092",
    security_protocol ="plaintext")

#Connection to Kafka 
app = Application( 
    broker_address = connectionConfig,
    consumer_group ="time_series",
    auto_offset_reset ="earliest")

#Input topics 

input_topic_airline = app.topic("airline", value_deserializer="json")

# Create Streaming DataFrames connected to the input Kafka topics

sdf_airline = app.dataframe(topic=input_topic_airline)


# Define new features



#Connect composers with preprocessors 



#Pipeline definition 

HoltWintersPipe_pipeline =HoltWinters
HoltWintersPipe_metrics = [mae]


HoltWintersPipe = Pipeline(model = HoltWintersPipe_pipeline , metrics_list = HoltWintersPipe_metrics , name = "HoltWintersPipe",y="passengers",output_topic="HoltWintersBVR")

# Output topics initialization

output_topic_HoltWintersPipe = app.topic(HoltWintersPipe.output_topic, value_deserializer="json")


#Sdf for each pipeline 
#Train and predict method calls for each pipeline
#If the pipeline has an output topic then we call it 

sdf_HoltWintersPipe = sdf_airline.apply(HoltWintersPipe.train_and_predict).to_topic(output_topic_HoltWintersPipe)


# ---------- DASHBOARD SETUP ----------

def run_dash():
    dash_app = Dash(__name__)
    dash_app.layout = html.Div([
         html.H2("Pipelines' Plots" , style={
        'textAlign': 'center',  # Center the text

        'fontFamily': 'sans-serif',  # Change the font family
        'font-weight': 'normal',  # Make the text bold
        }),
        dcc.Interval(id='interval', n_intervals=0),
        dcc.Graph(id='live-graph')
    ])

    @dash_app.callback(
        Output('live-graph', 'figure'),
        Input('interval', 'n_intervals')
    )
    def update_graph(n):
        fig = make_subplots(rows=2, cols=1 , vertical_spacing=0.1)

        # Assumes `add_metrics_traces` is defined in your Pipeline class
        HoltWintersPipe.add_metrics_traces(fig, row=1, col=1)

        fig.update_layout(height=600, title="Live Metrics", margin=dict(t=40, b=40), showlegend=True )
        return fig

    dash_app.run(debug=True, use_reloader=False)


# Start Dash in a separate thread
#threading.Thread(target=run_dash, daemon=True).start()


if __name__ == '__main__':
    threading.Thread(target=run_dash, daemon=True).start()
    #update_data()
    # Run Quix Streams 
    app.run()

#Metric plots for each Pipeline

#HoltWintersPipe.metrics_plot()

