# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig
from quixstreams.kafka import ConnectionConfig
from pipeline import *

from river import preprocessing


from river import optim

from river import metrics

from river import linear_model
from dash import Dash
from dash.dependencies import Input, Output
# import dash_core_components as dcc
# import dash_html_components as html
from dash import dcc, html
import plotly.graph_objs as go
import threading
from plotly.subplots import make_subplots
# Define optimizers
SGD = optim.SGD(
    lr=0.1)


# Define preprocessors
standardScaler = preprocessing.StandardScaler()


# Define metrics
accuracy = metrics.Accuracy()


# Define live data algorithms
log_reg = linear_model.LogisticRegression(
    optimizer=SGD)


# Connection Configuration for quixstreams
connectionConfig = ConnectionConfig(

    bootstrap_servers="localhost:39092",
    security_protocol="plaintext")

# Connection to Kafka
app = Application(
    broker_address=connectionConfig,
    consumer_group="log_reg_cons",
    auto_offset_reset="earliest")

# Input topics

input_topic_phishing = app.topic("Phishing", value_deserializer="json")

# Create Streaming DataFrames connected to the input Kafka topics

sdf_phishing = app.dataframe(topic=input_topic_phishing)


# Define new features


# Connect composers with preprocessors
preprocessor_phishing = standardScaler


# Pipeline definition

linear_algorithm_pipeline = preprocessor_phishing | log_reg

linear_algorithm_metrics = [accuracy]
linear_algorithm = Pipeline(model=linear_algorithm_pipeline, model_name = 'LogisticRegression' , metrics_list=linear_algorithm_metrics,
                            name="linear_algorithm", y="is_phishing", output_topic="LogisticRegressionBVR")

# Output topics initialization

output_topic_linear_algorithm = app.topic(
    linear_algorithm.output_topic, value_deserializer="json")


# Sdf for each pipeline
# Train and predict method calls for each pipeline
# If the pipeline has an output topic then we call it

sdf_linear_algorithm = sdf_phishing.apply(
    linear_algorithm.train_and_predict).to_topic(output_topic_linear_algorithm)


# ---------- DASHBOARD SETUP ----------

def run_dash():
    dash_app = Dash(__name__)
    dash_app.layout = html.Div([
         html.H2("Pipelines' Plots" , style={
        'textAlign': 'center',  # Center the text

        'fontFamily': 'sans-serif',  # Change the font family
        'font-weight': 'normal',  # Make the text bold
        }),
        dcc.Interval(id='interval', n_intervals=0),
        dcc.Graph(id='live-graph'), 
        html.Div(
            children=[
                dcc.Graph(
                    id='live-stats',
                    style={'margin': 'auto', 'display': 'block', 'width':'70%'}
                )
            ]
        )
    ])

    @dash_app.callback(
        Output('live-graph', 'figure'),
        Input('interval', 'n_intervals')
    )
    def update_graph(n):
        fig = make_subplots(rows=2, cols=1 , vertical_spacing=0.1)

        # Assumes `add_metrics_traces` is defined in your Pipeline class
        linear_algorithm.add_metrics_traces(fig, row=1, col=1)

        fig.update_layout(height=600, title="Live Metrics", margin=dict(t=40, b=40), showlegend=True )
        return fig
    
    
    @dash_app.callback(
        Output(
            component_id='live-stats', 
            component_property='figure'
        ), 
        Input(
            component_id='interval', 
            component_property='n_intervals'
        )
    )    
    def update_stats(n):
        
        traces = []  
        
        linear_algorithm.add_stats_traces(traces) 
        if traces:
            fig = go.Figure(
                    data=traces, 
                    layout= go.Layout(
                        title='Statistics'
                    )
            )
            return fig    
    
        return go.Figure()
    
    dash_app.run(debug=True, use_reloader=False)


# Start Dash in a separate thread
#threading.Thread(target=run_dash, daemon=True).start()


if __name__ == '__main__':
    threading.Thread(target=run_dash, daemon=True).start()
    #update_data()
    # Run Quix Streams 
    app.run()

#Metric plots for each Pipeline

#HoltWintersPipe.metrics_plot()

