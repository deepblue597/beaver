
# Autogenerated using jinja files
from quixstreams import Application
from quixstreams.kafka import ConnectionConfig 
from beaver.pipeline import Pipeline
from dash import Dash
from dash.dependencies import Input, Output
from dash import dcc, html
import plotly.graph_objs as go
import threading
from plotly.subplots import make_subplots


from river import stats
from river import anomaly
from river import preprocessing
from river import metrics




mean = stats.Mean(
)
halfspace = anomaly.HalfSpaceTrees(
    n_trees =5,
    height =3,
    window_size =3,
    seed =42
)
deviation = anomaly.StandardAbsoluteDeviation(
    sub_stat =mean
)
svm = anomaly.OneClassSVM(
    nu =0.2
)
quantile = anomaly.QuantileFilter(
    anomaly_detector =svm,
    q =0.995
)
scaler = preprocessing.StandardScaler(
)
precision = metrics.Precision(
)
rocauc = metrics.ROCAUC(
)
recall = metrics.Recall(
)



#Define connection
connectionConfig = ConnectionConfig(
    bootstrap_servers = 'localhost:39092',
    security_protocol = 'plaintext',
)

#Connection to Kafka
app = Application( 
    broker_address = connectionConfig,
    consumer_group = 'creditCard',
    auto_offset_reset = 'earliest',
)

#Input topics 

input_topic_CreditCard = app.topic("CreditCard", value_deserializer="json")

# Create Streaming DataFrames connected to the input Kafka topics

sdf_CreditCard = app.dataframe(topic=input_topic_CreditCard)

#Drop Features


#Keep Features




#Connect composers with preprocessors 

preprocessor_CreditCard =((scaler))



#Pipeline definition 

halfspacePipeline_pipeline = preprocessor_CreditCard |halfspace
halfspacePipeline_metrics = [precision,recall]


halfspacePipeline = Pipeline(model = halfspacePipeline_pipeline, model_name ='HalfSpaceTrees'  , metrics_list = halfspacePipeline_metrics , name = "halfspacePipeline",y="Class",output_topic="halfspacePipeline")

deviationPipeline_pipeline = preprocessor_CreditCard |deviation
deviationPipeline_metrics = [precision,recall]


deviationPipeline = Pipeline(model = deviationPipeline_pipeline, model_name ='StandardAbsoluteDeviation'  , metrics_list = deviationPipeline_metrics , name = "deviationPipeline",y="Class",output_topic="deviationPipeline")

quantilePipeline_pipeline = preprocessor_CreditCard |quantile
quantilePipeline_metrics = [precision,recall]


quantilePipeline = Pipeline(model = quantilePipeline_pipeline, model_name ='QuantileFilter'  , metrics_list = quantilePipeline_metrics , name = "quantilePipeline",y="Class",output_topic="quantilePipeline")



# Output topics initialization

output_topic_halfspacePipeline = app.topic(halfspacePipeline.output_topic, value_deserializer="json")

output_topic_deviationPipeline = app.topic(deviationPipeline.output_topic, value_deserializer="json")

output_topic_quantilePipeline = app.topic(quantilePipeline.output_topic, value_deserializer="json")



#Sdf for each pipeline 
#Train and predict method calls for each pipeline
#If the pipeline has an output topic then we call it 

sdf_halfspacePipeline = sdf_CreditCard.apply(halfspacePipeline.train_and_predict).to_topic(output_topic_halfspacePipeline)
sdf_deviationPipeline = sdf_CreditCard.apply(deviationPipeline.train_and_predict).to_topic(output_topic_deviationPipeline)
sdf_quantilePipeline = sdf_CreditCard.apply(quantilePipeline.train_and_predict).to_topic(output_topic_quantilePipeline)


# ---------- DASHBOARD SETUP ----------

def run_dash():
    dash_app = Dash(__name__)
    dash_app.layout = html.Div([
         html.H2("Pipelines' Plots" , style={
        'textAlign': 'center',  # Center the text

        'fontFamily': 'sans-serif',  # Change the font family
        'font-weight': 'normal',  # Make the text bold
        }),
        dcc.Interval(id='interval', n_intervals=0),
        dcc.Graph(id='live-graph'), 
        html.Div(
            children=[
                
                dcc.Graph(
                    id='live-stats-halfspacePipeline',
                    #style={'margin': 'auto', 'display': 'block', 'width':'70%'}
                ),
                dcc.Graph(
                    id='live-stats-deviationPipeline',
                    #style={'margin': 'auto', 'display': 'block', 'width':'70%'}
                ),
                dcc.Graph(
                    id='live-stats-quantilePipeline',
                    #style={'margin': 'auto', 'display': 'block', 'width':'70%'}
                )
            ]
        )
    ])

    @dash_app.callback(
        Output('live-graph', 'figure'),
        Input('interval', 'n_intervals')
    )
    def update_graph(n):
        fig = make_subplots(rows=3, cols=1 , vertical_spacing=0.1)

        
        halfspacePipeline.add_metrics_traces(fig = fig , row = 1, col = 1 ) 
        
        deviationPipeline.add_metrics_traces(fig = fig , row = 2, col = 1 ) 
        
        quantilePipeline.add_metrics_traces(fig = fig , row = 3, col = 1 ) 
        

        fig.update_layout(height=600, title="Live Metrics", margin=dict(t=40, b=40), showlegend=True )
        return fig


    
    @dash_app.callback(
        Output(
            component_id='live-stats-halfspacePipeline', 
            component_property='figure'
        ), 
        Input(
            component_id='interval', 
            component_property='n_intervals'
        )
    )

      
    def update_stats_halfspacePipeline(n):
        
        traces = []  
        
        halfspacePipeline.add_stats_traces(traces) 
              

        
        if traces:
            fig = go.Figure(
                    data=traces, 
                    layout= go.Layout(
                        title='halfspacePipeline Statistics'
                    )
            )
            return fig    
    
        return go.Figure()
    
    @dash_app.callback(
        Output(
            component_id='live-stats-deviationPipeline', 
            component_property='figure'
        ), 
        Input(
            component_id='interval', 
            component_property='n_intervals'
        )
    )

      
    def update_stats_deviationPipeline(n):
        
        traces = []  
        
        deviationPipeline.add_stats_traces(traces) 
              

        
        if traces:
            fig = go.Figure(
                    data=traces, 
                    layout= go.Layout(
                        title='deviationPipeline Statistics'
                    )
            )
            return fig    
    
        return go.Figure()
    
    @dash_app.callback(
        Output(
            component_id='live-stats-quantilePipeline', 
            component_property='figure'
        ), 
        Input(
            component_id='interval', 
            component_property='n_intervals'
        )
    )

      
    def update_stats_quantilePipeline(n):
        
        traces = []  
        
        quantilePipeline.add_stats_traces(traces) 
              

        
        if traces:
            fig = go.Figure(
                    data=traces, 
                    layout= go.Layout(
                        title='quantilePipeline Statistics'
                    )
            )
            return fig    
    
        return go.Figure()
    
    dash_app.run(debug=False, use_reloader=False)

if __name__ == '__main__':
    #Run Plotly on different thread
    threading.Thread(target=run_dash, daemon=True).start()
   
    # Run Quix Streams 
    app.run()