# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig

from river import metrics , preprocessing
from river import tree
import matplotlib.pyplot as plt
from river import ensemble
from river import optim


import dill


# Define an application that will connect to Kafka
app = Application(
    broker_address="localhost:39092",  # Kafka broker address
    auto_offset_reset="earliest",
    consumer_group="boston-model-2",
)

# Define the Kafka topics
input_topic = app.topic("boston-house-prices", value_deserializer="json")

# Create a Streaming DataFrame connected to the input Kafka topic
sdf = app.dataframe(topic=input_topic)

# Define River Model
model =(
    
    preprocessing.StandardScaler()|
    tree.HoeffdingAdaptiveTreeRegressor(
    
        grace_period = 50,
        model_selector_decay = 0.3,
        seed = 0,

    )
)
    





# Define metrics
metric = metrics.MAE() +metrics.MSE() 
   
MAE = [] 
MSE = [] 
 






# Variables for plotting
x_axis = []
y_true = []
y_pred = []


# Function for training the model
def train_and_predict(event):

    X = { 
        "CRIM": event["CRIM"],
        "ZN": event["ZN"],
        "INDUS": event["INDUS"],
        "CHAS": event["CHAS"],
        "NOX": event["NOX"],
        "RM": event["RM"],
        "AGE": event["AGE"],
        "DIS": event["DIS"],
        "RAD": event["RAD"],
        "TAX": event["TAX"],
        "PTRATIO": event["PTRATIO"],
        "B": event["B"],
        "LSTAT": event["LSTAT"],
        "MEDV": event["MEDV"],
        
    }

    
    y = event["MEDV"]
     
    
    model.learn_one(X, y)
     
    
    y_predicted = model.predict_one(X)
    

    # Update accuracy metric
    metric.update(y, y_predicted)
    
    print(metric)

    MAE.append(metric.get()[0])
    
    MSE.append(metric.get()[1])
    
     

    with open('HoeffdingAdaptiveTreeRegressor.pkl', 'wb') as model_file:
        dill.dump(model, model_file)

    
    x_axis.append(event["CRIM"])
    y_true.append(y)
    y_pred.append(y_predicted)
    


    return event


# Apply the train_and_predict function to each row in the filtered DataFrame
sdf = sdf.apply(train_and_predict)

# Run the streaming application (app automatically tracks the sdf!)
app.run()


# Plot the data
plt.figure(figsize=(10, 5))
plt.plot(x_axis, y_true, label='y')
plt.plot(x_axis, y_pred, label='Predicted y', linestyle='--')
plt.xlabel("CRIM")
plt.ylabel("MEDV")
plt.title("MEDV over  CRIM ")
plt.legend()
plt.show()



plt.plot(MAE)
plt.xlabel('Iterations')
plt.ylabel('MAE')
plt.title('MAE over Training Iterations')
plt.show()
plt.plot(MSE)
plt.xlabel('Iterations')
plt.ylabel('MSE')
plt.title('MSE over Training Iterations')
plt.show()
 