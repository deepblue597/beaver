# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig
import seaborn as sns

from river import metrics, preprocessing
from river import forest
import matplotlib.pyplot as plt
from river import ensemble
from river import optim
from sklearn.metrics import confusion_matrix
from river import compose
from river import preprocessing
import json

import dill


# Define an application that will connect to Kafka
app = Application(
    broker_address="localhost:39092",  # Kafka broker address
    auto_offset_reset="earliest",
    consumer_group="AMFClassifier",
)

# Define the Kafka topics
input_topic = app.topic("Bananas", value_deserializer="json")

output_topic = app.topic("AMFClassifier-results",
                         # Create a Streaming DataFrame connected to the input Kafka topic
                         value_serializer="json")
sdf = app.dataframe(topic=input_topic)


# Define River Model
model = (

    forest.AMFClassifier(

        n_estimators=10,
        use_aggregation=True,
        dirichlet=0.5,
        seed=1,

    ))


# Define new features


# Drop features


# Define metrics
metric = metrics.Accuracy()

Accuracy = []


# Variables for plotting
y_true = []
y_pred = []


# Function for training the model
def train_and_predict(event):

    X = {key: value for key, value in event.items() if key != "class"}

    y = event["class"]

    model.learn_one(X, y)

    y_predicted = model.predict_one(X)

    # Update metric
    metric.update(y, y_predicted)

    # print(f"True y: {y}, Predicted: {y_predicted}")

    print(metric)
    Accuracy.append(metric.get())

    with open('AMFClassifier.pkl', 'wb') as model_file:
        dill.dump(model, model_file)

    # in some cases model returns one (e.g first learn one iteration in OneVsOneClassifier)
    # so we check if y_pred is not None to add to the lists
    if y_predicted is not None:
        y_true.append(y)
        y_pred.append(y_predicted)

    return {
        **event,

        "Prediction": y_predicted,
        "Accuracy": metric.get()

    }


# Apply the train_and_predict function to each row in the filtered DataFrame
sdf = sdf.apply(train_and_predict)

# Output topic
# Run the streaming application (app automatically tracks the sdf!)
sdf = sdf.to_topic(output_topic)
app.run()


# Generate the confusion matrix
cm = confusion_matrix(y_true, y_pred)

# Create a heatmap of the confusion matrix
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=[
            'Class 0', 'Class 1'], yticklabels=['Class 0', 'Class 1'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Heatmap')
plt.show()


plt.plot(Accuracy)
plt.xlabel('Iterations')
plt.ylabel('Accuracy')
plt.title('Accuracy over Training Iterations')
plt.show()
