# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig
import seaborn as sns

from river import metrics , preprocessing
from river import cluster
import matplotlib.pyplot as plt
from river import ensemble
from river import optim
from sklearn.metrics import confusion_matrix
from river import compose
from river import preprocessing
import json

import dill
import numpy as np 


# Define an application that will connect to Kafka
app = Application(
    broker_address="localhost:39092",  # Kafka broker address
    auto_offset_reset="earliest",
    consumer_group="DenStream",
)

# Define the Kafka topics
input_topic = app.topic("clusters", value_deserializer="json")

output_topic = app.topic("DenStream-results",
                        value_serializer="json")# Create a Streaming DataFrame connected to the input Kafka topic
sdf = app.dataframe(topic=input_topic)




# Define River Model
model =(
    
    cluster.DenStream(
    
        decaying_factor = 0.01,
        beta = 0.5,
        mu = 2.5,
        epsilon = 0.5,
        n_samples_init = 10,

    ))
    


# Define new features


# Drop features 


# Define metrics
metric = metrics.Silhouette() 
   
Silhouette = [] 
 







# Function for training the model
def train_and_predict(X):

     
    

    
    model.learn_one(X)
     
    
    
    y_predicted = model.predict_one(X)
    
    
    # Update metric
    metric.update(X, y_predicted,  model.centers)

    
    print(metric)
    Silhouette.append(metric.get()) 
    
    


    with open('DenStream.pkl', 'wb') as model_file:
        dill.dump(model, model_file)

    


    return {
                **X, 
                
                "Prediction": y_predicted,
                "Silhouette": metric.get()
                
            }


# Apply the train_and_predict function to each row in the filtered DataFrame
sdf = sdf.apply(train_and_predict)

# Output topic 
sdf = sdf.to_topic(output_topic)# Run the streaming application (app automatically tracks the sdf!)
app.run()




plt.plot(Silhouette)
plt.xlabel('Iterations')
plt.ylabel('Silhouette')
plt.title('Silhouette over Training Iterations')
plt.show()
 