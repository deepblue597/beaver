#%%
# Autogenerated from python.template file

from quixstreams import Application
from quixstreams.models import TopicConfig
from quixstreams.kafka import ConnectionConfig 
import seaborn as sns

from river import metrics , preprocessing
from river import anomaly
import matplotlib.pyplot as plt
from river import ensemble
from river import optim
from sklearn.metrics import confusion_matrix
from river import compose
from river import preprocessing
import json

import dill
import numpy as np 
#%%
connection_settings = ConnectionConfig(
    bootstrap_servers="localhost:39092",
    security_protocol="sasl_plaintext",
    sasl_mechanism="PLAIN",
    sasl_username="admin",
    sasl_password="admin-secret",

)

# Define an application that will connect to Kafka
app = Application(
    broker_address= connection_settings,  # Kafka broker address
    auto_offset_reset="earliest",
    consumer_group="halfSpaceTree",
)

# Define the Kafka topics
input_topic = app.topic("CreditCard", value_deserializer="json")

# Create a Streaming DataFrame connected to the input Kafka topic
sdf = app.dataframe(topic=input_topic)



#Define preprocessing

preprocessor_0 = preprocessing.MinMaxScaler()

# Define River Model
model =(
    (
    
    preprocessor_0)|
    
    anomaly.HalfSpaceTrees(
    
        n_trees = 5,
        height = 3,
        window_size = 3,
        seed = 42,

    ))
    


# Define new features


# Drop features 

#%%
# Define metrics
metric = metrics.MAE() + metrics.MSE() 
for metric in metric:
    print(metric.__class__.__name__)

#%%
MAE = [] 
 






# Variables for plotting

y_true = []
y_pred = []


# Function for training the model
def train_and_predict(X):

    
    y = X["class"]
     
    
    X = {key: value for key, value in X.items() if key != "class"}  
    

    
    model.learn_one(X, y)
     
    
    
    y_predicted = model.predict_one(X)
    
    
    # Update metric
    
    metric.update(y, y_predicted )

    
    print(f"True y: {y}, Predicted: {y_predicted}")
    
    print(metric)
    MAE.append(metric.get()) 
    
    


    with open('HalfSpaceTrees.pkl', 'wb') as model_file:
        dill.dump(model, model_file)

    
    



    # in some cases model returns one (e.g first learn one iteration in OneVsOneClassifier)
    # so we check if y_pred is not None to add to the lists
    if y_predicted is not None:
        y_true.append(y)
        y_pred.append(y_predicted)
        


    return X


# Apply the train_and_predict function to each row in the filtered DataFrame
sdf = sdf.apply(train_and_predict)

# Run the streaming application (app automatically tracks the sdf!)
app.run()



# Generate the confusion matrix
cm = confusion_matrix(y_true, y_pred)

# Create a heatmap of the confusion matrix
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Class 0', 'Class 1'], yticklabels=['Class 0', 'Class 1'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Heatmap')
plt.show()




plt.plot(MAE)
plt.xlabel('Iterations')
plt.ylabel('MAE')
plt.title('MAE over Training Iterations')
plt.show()
 